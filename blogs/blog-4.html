<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building a Production-Ready Speech Annotation Tool - Praveen Kumar</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Deep dive into building a production-ready speech annotation platform for transcription review and correction. Learn about background job processing, progress tracking, session persistence, and deploying with Flask, Whisper, and FFmpeg.">
    <meta name="keywords" content="Speech Annotation, ASR, Whisper, Flask, Background Jobs, Audio Processing, FFmpeg, Data Annotation, Python, Web Development">
    <meta name="author" content="Praveen Kumar">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Building a Production-Ready Speech Annotation Tool">
    <meta property="og:description" content="Complete guide to building a speech annotation platform with background job processing, progress tracking, session persistence, and smart row locking. From concept to deployment.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://inboxpraveen.github.io/blogs/blog-4.html">
    <meta property="og:image" content="https://inboxpraveen.github.io/blogs/resources/blog-4/Header.png">
    <meta property="og:image:alt" content="Speech Annotation Tool Architecture">
    <meta property="og:site_name" content="Praveen Kumar Portfolio">
    <meta property="article:published_time" content="2025-12-08">
    <meta property="article:author" content="Praveen Kumar">
    <meta property="article:tag" content="Flask">
    <meta property="article:tag" content="Audio Processing">
    <meta property="article:tag" content="Background Jobs">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Building a Production-Ready Speech Annotation Tool">
    <meta name="twitter:description" content="Master background job processing, session persistence, and audio handling. Complete guide to building scalable annotation platforms with Flask and Whisper.">
    <meta name="twitter:image" content="https://inboxpraveen.github.io/blogs/resources/blog-4/Header.png">
    <meta name="twitter:image:alt" content="Speech Annotation Tool">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://inboxpraveen.github.io/blogs/blog-4.html">
    
    <link rel="icon" type="image/x-icon" href="../assests/favicon.ico">
    <link rel="stylesheet" href="../index.css">
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <div class="logo" onclick="window.location.href='../index.html'" style="cursor: pointer;">PK</div>
            <ul class="nav-links" id="navLinks">
                <li><a href="../index.html">Home</a></li>
                <li><a href="../index.html#about">About</a></li>
                <li><a href="../index.html#projects">Projects</a></li>
                <li><a href="../index.html#blog">Blog</a></li>
                <li><a href="../index.html#contact">Contact</a></li>
                <li><a href="../assests/Resume.pdf" target="_blank" title="Updated Nov 2025">Resume</a></li>
            </ul>
            <button class="mobile-menu" id="mobileMenu">‚ò∞</button>
        </div>
    </nav>

    <!-- Blog Post Page - Speech Annotation Tool -->
    <div class="page-container active">
        <div class="page-header">
            <div class="container">
                <a href="../all-blogs.html" class="back-button">‚Üê Back to Blog</a>
                <h1 class="page-title">Building a Production-Ready Speech Annotation Tool</h1>
                <div class="page-meta">
                    <div class="meta-item">
                        <span>üìÖ</span>
                        <span>Published: December 8, 2025</span>
                    </div>
                    <div class="meta-item">
                        <span>‚è±Ô∏è</span>
                        <span>18 min read</span>
                    </div>
                    <div class="meta-item">
                        <span>üè∑Ô∏è</span>
                        <span>Flask ‚Ä¢ Audio Processing ‚Ä¢ Background Jobs</span>
                    </div>
                    <div class="meta-item">
                        <span>üëÅÔ∏è</span>
                        <span>342 views</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="blog-content-area">
            <div style="text-align: center; margin: 2rem 0;">
                <img src="resources/blog-4/Header.png" alt="Speech Annotation Tool Header" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);">
            </div>
            
            <p>
                Data annotation teams face a universal challenge: reviewing and correcting thousands of transcriptions 
                from automatic speech recognition (ASR) systems is tedious, error-prone, and becomes a bottleneck in 
                any speech AI pipeline. Building a tool to streamline this process is non-trivial‚Äîyou need to handle 
                large audio files, track progress asynchronously, persist session state, and prevent accidental edits.
            </p>

            <p>
                In this deep dive, I'll walk you through building a <strong>production-ready speech annotation platform</strong> 
                that handles these challenges elegantly. We'll cover the complete architecture including intelligent 
                <strong>background job processing without external queues</strong>, <strong>real-time progress tracking</strong>, 
                <strong>browser-based session persistence</strong>, and <strong>smart row locking</strong>. The result is a 
                lightweight yet powerful tool built on Flask, Whisper, and FFmpeg that can scale from a solo annotator to 
                large data teams.
            </p>

            <h2>The Problem: Why Transcription Review Is Hard</h2>
            <p>
                On the surface, transcription review seems straightforward: <em>"Load audio, display text, let users edit and save."</em> 
                But real-world complexity emerges quickly:
            </p>

            <ul>
                <li><strong>Large Audio Files:</strong> Loading a 500MB audio file into memory is catastrophic for performance</li>
                <li><strong>Long-Running Operations:</strong> Transcribing 1,000 audio files blocks the UI without background processing</li>
                <li><strong>Data Integrity:</strong> How do you prevent multiple users from editing the same record?</li>
                <li><strong>Session State:</strong> Users should see which records they've corrected even after browser refresh</li>
                <li><strong>Progress Visibility:</strong> Annotators need real-time feedback on job progress, not spinning loaders</li>
                <li><strong>Audio Compatibility:</strong> MP3, WAV, OGG, FLAC‚Äîusers have files in every format imaginable</li>
            </ul>

            <p>
                A production system must solve all of these gracefully.
            </p>

            <h2>The Architecture: Two Complementary Workflows</h2>
            
            <div style="text-align: center; margin: 2rem 0;">
                <img src="resources/blog-4/Architecture.png" alt="Speech Annotation Tool Architecture" style="max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);">
            </div>

            <p>
                The tool elegantly solves this by supporting two distinct workflows, each optimized for different use cases:
            </p>

            <h3>Workflow 1: Review & Correct (For Pre-Transcribed Audio)</h3>
            <p>
                Perfect for teams with chunked audio files and Excel transcripts already prepared. Users load both 
                simultaneously, and the platform:
            </p>
            <ul>
                <li>Imports records from Excel (with file validation)</li>
                <li>Streams audio segments on-demand (not all at once)</li>
                <li>Provides inline editing with autosave</li>
                <li>Tracks corrections in browser localStorage</li>
                <li>Allows selective locking of completed rows</li>
            </ul>

            <h3>Workflow 2: Auto-Transcribe (For Raw Audio Folders)</h3>
            <p>
                For users starting from scratch. They provide a folder of audio files and select a Whisper model, 
                and the platform:
            </p>
            <ul>
                <li>Automatically converts to standard format (16kHz mono WAV)</li>
                <li>Chunks audio into fixed-duration segments (default 30 seconds)</li>
                <li>Transcribes each segment using Whisper in background</li>
                <li>Shows real-time progress in UI</li>
                <li>Allows review and correction immediately after transcription</li>
            </ul>

            <h2>Background Job Processing: Without External Queues</h2>
            <p>
                The most critical component for production use is reliable background job processing. I chose 
                <strong>Python threading</strong> instead of Celery/Redis for a specific reason: simplicity without sacrificing functionality.
            </p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">Python - Job Manager Architecture</span>
                    <button class="copy-button">Copy</button>
                </div>
                <pre><code><span class="keyword">from</span> enum <span class="keyword">import</span> Enum
<span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass
<span class="keyword">from</span> threading <span class="keyword">import</span> Thread, RLock
<span class="keyword">import</span> json
<span class="keyword">from</span> pathlib <span class="keyword">import</span> Path

<span class="keyword">class</span> <span class="function">JobType</span>(Enum):
    TRANSCRIBE = <span class="string">"transcribe"</span>
    MANUAL_IMPORT = <span class="string">"manual_import"</span>

<span class="keyword">class</span> <span class="function">JobManager</span>:
    <span class="string">"""Singleton manager for background jobs with type-based locking"""</span>
    
    _instance = <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        self._jobs = {}  <span class="comment"># Dict[job_id, JobInfo]</span>
        self._active_jobs_by_type = {}  <span class="comment"># Lock: only 1 per type</span>
        self._lock = RLock()
        self._jobs_file = Path(<span class="string">'data/jobs.json'</span>)
        self._load_jobs_state()
    
    <span class="keyword">def</span> <span class="function">create_job</span>(self, job_id: str, job_type: JobType, 
                  total_items: int, metadata: dict = <span class="keyword">None</span>):
        <span class="string">"""Create a new job"""</span>
        <span class="keyword">with</span> self._lock:
            job_info = {
                <span class="string">'job_id'</span>: job_id,
                <span class="string">'job_type'</span>: job_type.value,
                <span class="string">'status'</span>: <span class="string">'pending'</span>,
                <span class="string">'progress'</span>: 0,
                <span class="string">'total_items'</span>: total_items,
                <span class="string">'processed_items'</span>: 0,
                <span class="string">'metadata'</span>: metadata or {},
            }
            self._jobs[job_id] = job_info
            self._save_jobs_state()
            <span class="keyword">return</span> job_info
    
    <span class="keyword">def</span> <span class="function">can_start_job</span>(self, job_type: JobType):
        <span class="string">"""Check if another job of this type is already running"""</span>
        <span class="keyword">with</span> self._lock:
            active_id = self._active_jobs_by_type.get(job_type)
            <span class="keyword">if</span> active_id:
                <span class="keyword">return</span> False, active_id
            <span class="keyword">return</span> True, <span class="keyword">None</span>
    
    <span class="keyword">def</span> <span class="function">run_job_async</span>(self, job_id: str, job_type: JobType, 
                    task_func, total_items: int, metadata: dict = <span class="keyword">None</span>):
        <span class="string">"""Start a background job in a daemon thread"""</span>
        job_info = self.create_job(job_id, job_type, total_items, metadata)
        
        <span class="keyword">def</span> <span class="function">wrapper</span>():
            <span class="keyword">try</span>:
                <span class="comment"># Acquire lock for this job type</span>
                can_start, active_id = self.can_start_job(job_type)
                <span class="keyword">if</span> <span class="keyword">not</span> can_start:
                    self.fail_job(job_id, 
                                 <span class="string">f"Another {job_type.value} job already running"</span>)
                    <span class="keyword">return</span>
                
                <span class="keyword">with</span> self._lock:
                    self._active_jobs_by_type[job_type] = job_id
                    self._jobs[job_id][<span class="string">'status'</span>] = <span class="string">'running'</span>
                    self._save_jobs_state()
                
                <span class="comment"># Run the actual task</span>
                result = task_func(job_id, self)
                self.complete_job(job_id, result)
                
            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
                self.fail_job(job_id, str(e))
            <span class="keyword">finally</span>:
                <span class="keyword">with</span> self._lock:
                    self._active_jobs_by_type.pop(job_type, <span class="keyword">None</span>)
        
        <span class="comment"># Start in background thread</span>
        thread = Thread(target=wrapper, daemon=<span class="keyword">True</span>)
        thread.start()
        
        <span class="keyword">return</span> job_info
    
    <span class="keyword">def</span> <span class="function">update_progress</span>(self, job_id: str, processed: int, 
                       total: int):
        <span class="string">"""Update job progress"""</span>
        <span class="keyword">with</span> self._lock:
            <span class="keyword">if</span> job_id <span class="keyword">in</span> self._jobs:
                self._jobs[job_id][<span class="string">'processed_items'</span>] = processed
                self._jobs[job_id][<span class="string">'progress'</span>] = <span class="keyword">int</span>(
                    (processed / total * <span class="number">100</span>) <span class="keyword">if</span> total > <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>
                )
                self._save_jobs_state()</code></pre>
            </div>

            <h3>Why Threading Instead of Celery?</h3>
            <p>
                Threading is often dismissed in favor of task queues like Celery, but for a single-server deployment with 
                moderate load, it offers significant advantages:
            </p>

            <div class="table-container">
                <table class="content-table">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Threading</th>
                            <th>Celery + Redis</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Setup Complexity</td>
                            <td>Zero config (built-in)</td>
                            <td>Redis broker + workers required</td>
                        </tr>
                        <tr>
                            <td>Memory Overhead</td>
                            <td>Minimal (~10MB)</td>
                            <td>Redis server + workers (200MB+)</td>
                        </tr>
                        <tr>
                            <td>Deployment</td>
                            <td>Single process</td>
                            <td>Multiple services to manage</td>
                        </tr>
                        <tr>
                            <td>Use Case</td>
                            <td>Solo to small teams</td>
                            <td>Distributed, high-volume</td>
                        </tr>
                        <tr>
                            <td>State Persistence</td>
                            <td>JSON file (simple)</td>
                            <td>Automatic (Redis)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h2>Audio Processing: From MP3 to Segments</h2>
            <p>
                A critical component is robust audio handling. Users upload MP3, FLAC, OGG, WMA‚Äîanything. The system 
                needs to normalize everything to a consistent format and chunk into manageable pieces.
            </p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">Python - Audio Processing Pipeline</span>
                    <button class="copy-button">Copy</button>
                </div>
                <pre><code><span class="keyword">import</span> subprocess
<span class="keyword">from</span> pathlib <span class="keyword">import</span> Path

<span class="keyword">def</span> <span class="function">convert_to_wav</span>(source_path: Path, job_id: str) -> Path:
    <span class="string">"""
    Convert any audio format to 16kHz mono WAV using FFmpeg.
    FFmpeg handles format detection automatically.
    """</span>
    
    output_wav = Path(<span class="string">f"data/segments/{job_id}/audio.wav"</span>)
    output_wav.parent.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)
    
    <span class="comment"># FFmpeg command: convert to 16kHz mono WAV</span>
    cmd = [
        <span class="string">'ffmpeg'</span>,
        <span class="string">'-i'</span>, str(source_path),
        <span class="string">'-ar'</span>, <span class="string">'16000'</span>,        <span class="comment"># Audio rate: 16kHz</span>
        <span class="string">'-ac'</span>, <span class="string">'1'</span>,           <span class="comment"># Channels: 1 (mono)</span>
        <span class="string">'-c:a'</span>, <span class="string">'pcm_s16le'</span>,  <span class="comment"># Codec: 16-bit PCM</span>
        <span class="string">'-y'</span>, str(output_wav)
    ]
    
    subprocess.run(cmd, check=<span class="keyword">True</span>, 
                   capture_output=<span class="keyword">True</span>)
    <span class="keyword">return</span> output_wav

<span class="keyword">def</span> <span class="function">segment_audio</span>(wav_path: Path, job_id: str, 
                 segment_seconds: int = <span class="number">30</span>) -> List[Path]:
    <span class="string">"""
    Split WAV file into fixed-duration segments.
    Uses FFmpeg for efficient splitting without re-encoding.
    """</span>
    
    segment_dir = Path(<span class="string">f"data/segments/{job_id}"</span>)
    segment_dir.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)
    
    <span class="comment"># Get total duration in seconds</span>
    duration_cmd = [
        <span class="string">'ffprobe'</span>,
        <span class="string">'-v'</span>, <span class="string">'error'</span>,
        <span class="string">'-show_entries'</span>, <span class="string">'format=duration'</span>,
        <span class="string">'-of'</span>, <span class="string">'default=noprint_wrappers=1:nokey=1:noprint_wrappers=1'</span>,
        str(wav_path)
    ]
    
    duration_result = subprocess.run(duration_cmd, capture_output=<span class="keyword">True</span>,
                                    text=<span class="keyword">True</span>, check=<span class="keyword">True</span>)
    total_seconds = float(duration_result.stdout.strip())
    
    segments = []
    segment_index = 0
    current_start = 0.0
    
    <span class="keyword">while</span> current_start < total_seconds:
        current_end = min(current_start + segment_seconds, total_seconds)
        duration = current_end - current_start
        
        segment_path = segment_dir / <span class="string">f"{segment_index:03d}.wav"</span>
        
        <span class="comment"># FFmpeg trim: extract segment without re-encoding</span>
        trim_cmd = [
            <span class="string">'ffmpeg'</span>,
            <span class="string">'-i'</span>, str(wav_path),
            <span class="string">'-ss'</span>, str(current_start),
            <span class="string">'-t'</span>, str(duration),
            <span class="string">'-c'</span>, <span class="string">'copy'</span>,           <span class="comment"># No re-encoding</span>
            <span class="string">'-y'</span>, str(segment_path)
        ]
        
        subprocess.run(trim_cmd, check=<span class="keyword">True</span>,
                      capture_output=<span class="keyword">True</span>)
        
        segments.append(segment_path)
        current_start = current_end
        segment_index += 1
    
    <span class="keyword">return</span> segments</code></pre>
            </div>

            <p>
                Key design decisions:
            </p>
            <ul>
                <li><strong>FFmpeg, not Python libraries:</strong> FFmpeg is battle-tested, handles all formats, and is orders of magnitude faster</li>
                <li><strong>Stream processing:</strong> Never load entire audio into memory‚Äîprocess in chunks</li>
                <li><strong>16kHz mono:</strong> Whisper expects this format, so normalize upfront</li>
                <li><strong>Segment by duration:</strong> Fixed 30-second segments balance context and manageability</li>
            </ul>

            <h2>Session Persistence: LocalStorage for Tracking</h2>
            <p>
                One challenge with web applications is that users expect their work to persist across browser refreshes. 
                Without a backend database per user, we can leverage browser localStorage to track corrections.
            </p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">JavaScript - Correction Tracker</span>
                    <button class="copy-button">Copy</button>
                </div>
                <pre><code><span class="keyword">class</span> <span class="function">CorrectionTracker</span> {
    <span class="function">constructor</span>() {
        this.storageKey = <span class="string">'asr_corrections_tracker'</span>;
        this.corrections = this._loadFromStorage();
    }
    
    _loadFromStorage() {
        <span class="keyword">const</span> data = localStorage.getItem(this.storageKey);
        <span class="keyword">return</span> data ? JSON.parse(data) : {};
    }
    
    _saveToStorage() {
        localStorage.setItem(this.storageKey, 
                           JSON.stringify(this.corrections));
    }
    
    markCorrected(recordId, originalText, correctedText) {
        <span class="string">"""Mark a record as corrected"""</span>
        this.corrections[recordId] = {
            corrected: <span class="keyword">true</span>,
            originalText: originalText,
            correctedText: correctedText,
            timestamp: <span class="keyword">new</span> Date().toISOString()
        };
        this._saveToStorage();
    }
    
    isCorrected(recordId) {
        <span class="keyword">return</span> recordId <span class="keyword">in</span> this.corrections 
               && this.corrections[recordId].corrected;
    }
    
    getStats() {
        <span class="keyword">const</span> total = Object.keys(this.corrections).length;
        <span class="keyword">const</span> corrected = Object.values(
            this.corrections
        ).filter(c => c.corrected).length;
        
        <span class="keyword">return</span> { total, corrected, progress: 
                  total > 0 ? (corrected / total * 100).toFixed(1) : 0 };
    }
    
    <span class="comment">// Usage:</span>
    <span class="comment">// tracker.markCorrected('uuid-1', 'Original', 'Corrected')</span>
    <span class="comment">// tracker.isCorrected('uuid-1') ‚Üí true</span>
    <span class="comment">// tracker.getStats() ‚Üí {total: 47, corrected: 23, progress: 48.9%}</span>
}</code></pre>
            </div>

            <h2>Smart Row Locking: Prevent Accidental Overwrites</h2>
            <p>
                Once an annotator finishes editing a record, they should be able to "lock" it to prevent accidental changes. 
                This is stored both in the CSV backend and checked on save.
            </p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">Python - Row Locking Logic</span>
                    <button class="copy-button">Copy</button>
                </div>
                <pre><code><span class="keyword">def</span> <span class="function">update_record</span>(record_id: str, 
                  corrected_text: str) -> Tuple[bool, str]:
    <span class="string">"""Update a record's correction, respecting locks"""</span>
    
    <span class="keyword">with</span> _lock:  <span class="comment"># Thread-safe</span>
        df = pd.read_csv(STATE_FILE)
        record = df[df[<span class="string">'id'</span>] == record_id]
        
        <span class="keyword">if</span> record.empty:
            <span class="keyword">return</span> False, <span class="string">"Record not found"</span>
        
        <span class="keyword">if</span> record[<span class="string">'locked'</span>].iloc[<span class="number">0</span>]:
            <span class="keyword">return</span> False, <span class="string">"Record is locked. Unlock first."</span>
        
        <span class="comment"># Update the record</span>
        df.loc[df[<span class="string">'id'</span>] == record_id, 
               <span class="string">'correct_transcripts'</span>] = corrected_text
        
        pd.to_csv(STATE_FILE, index=<span class="keyword">False</span>)
        <span class="keyword">return</span> True, <span class="string">"Record updated"</span>

<span class="keyword">def</span> <span class="function">lock_record</span>(record_id: str) -> bool:
    <span class="string">"""Lock a record to prevent edits"""</span>
    
    <span class="keyword">with</span> _lock:
        df = pd.read_csv(STATE_FILE)
        df.loc[df[<span class="string">'id'</span>] == record_id, <span class="string">'locked'</span>] = True
        df.loc[df[<span class="string">'id'</span>] == record_id, <span class="string">'locked_at'</span>] = (
            pd.Timestamp.now().isoformat()
        )
        df.to_csv(STATE_FILE, index=<span class="keyword">False</span>)
        <span class="keyword">return</span> True</code></pre>
            </div>

            <h2>Real-Time Progress Tracking</h2>
            <p>
                The frontend polls the job status endpoint every 2 seconds while transcription runs, updating a progress banner:
            </p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">JavaScript - Job Polling</span>
                    <button class="copy-button">Copy</button>
                </div>
                <pre><code><span class="keyword">class</span> <span class="function">JobTracker</span> {
    <span class="function">constructor</span>() {
        this.jobId = <span class="keyword">null</span>;
        this.pollInterval = <span class="keyword">null</span>;
    }
    
    startTracking(jobId) {
        this.jobId = jobId;
        this.showBanner();
        this.startPolling();
    }
    
    startPolling() {
        this.pollInterval = setInterval(() => {
            fetch(<span class="string">`/api/jobs/${this.jobId}`</span>)
                .then(r => r.json())
                .then(jobInfo => {
                    this.updateBanner(jobInfo);
                    
                    <span class="keyword">if</span> (jobInfo.status === <span class="string">'completed'</span> 
                        || jobInfo.status === <span class="string">'failed'</span>) {
                        this.stopTracking();
                        location.reload(); <span class="comment"># Refresh to show results</span>
                    }
                });
        }, <span class="number">2000</span>); <span class="comment"># Poll every 2 seconds</span>
    }
    
    updateBanner(jobInfo) {
        <span class="keyword">const</span> progress = jobInfo.progress || 0;
        <span class="keyword">const</span> html = `
            <span class="keyword">&lt;div</span> <span class="keyword">class</span>=<span class="string">"job-banner"</span><span class="keyword">&gt;</span>
                <span class="keyword">&lt;div</span> <span class="keyword">class</span>=<span class="string">"progress-bar"</span><span class="keyword">&gt;</span>
                    <span class="keyword">&lt;div</span> <span class="keyword">class</span>=<span class="string">"progress-fill"</span> 
                         <span class="keyword">style</span>=<span class="string">"width: ${progress}%"</span><span class="keyword">&gt;&lt;/div&gt;</span>
                <span class="keyword">&lt;/div&gt;</span>
                <span class="keyword">&lt;p&gt;</span>Processing... 
                   ${jobInfo.processed_items}/${jobInfo.total_items} 
                   (${progress}%)<span class="keyword">&lt;/p&gt;</span>
            <span class="keyword">&lt;/div&gt;</span>
        `;
        document.getElementById(<span class="string">'job-status'</span>).innerHTML = html;
    }
    
    stopTracking() {
        clearInterval(this.pollInterval);
        this.jobId = <span class="keyword">null</span>;
    }
}</code></pre>
            </div>

            <h2>Deployment Architecture</h2>
            <p>
                The complete stack is designed for simplicity and reliability:
            </p>

            <div class="table-container">
                <table class="content-table">
                    <thead>
                        <tr>
                            <th>Component</th>
                            <th>Technology</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Web Framework</td>
                            <td>Flask 3.0+</td>
                            <td>Lightweight, minimal overhead</td>
                        </tr>
                        <tr>
                            <td>Speech Recognition</td>
                            <td>OpenAI Whisper</td>
                            <td>State-of-the-art ASR, runs locally</td>
                        </tr>
                        <tr>
                            <td>Audio Processing</td>
                            <td>FFmpeg</td>
                            <td>Format conversion, chunking</td>
                        </tr>
                        <tr>
                            <td>Data Storage</td>
                            <td>CSV + JSON</td>
                            <td>Simple, versionable, zero DB setup</td>
                        </tr>
                        <tr>
                            <td>Job Orchestration</td>
                            <td>Python Threading</td>
                            <td>Built-in, no external broker needed</td>
                        </tr>
                        <tr>
                            <td>Session Tracking</td>
                            <td>Browser localStorage</td>
                            <td>Client-side, survives refresh</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>Production Deployment</h3>
            <p>
                For production, deploy with Gunicorn behind Nginx:
            </p>

            <div class="code-block">
                <div class="code-header">
                    <span class="code-language">Bash - Production Deployment</span>
                    <button class="copy-button">Copy</button>
                </div>
                <pre><code><span class="comment"># 1. Install dependencies</span>
pip install -r requirements.txt
pip install gunicorn

<span class="comment"># 2. Start Gunicorn with 4 workers</span>
gunicorn -w 4 -b 0.0.0.0:5000 --timeout 300 app:app

<span class="comment"># 3. Nginx configuration (reverse proxy)</span>
server {
    listen 80;
    server_name yourdomain.com;
    
    location / {
        proxy_pass http://127.0.0.1:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        <span class="comment"># Allow large file uploads</span>
        client_max_body_size 500M;
        proxy_request_buffering off;
        proxy_buffering off;
    }
}</code></pre>
            </div>

            <h2>Performance Characteristics</h2>
            <p>
                Real-world measurements from production deployment:
            </p>

            <div class="table-container">
                <table class="content-table">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Time</th>
                            <th>Scalability</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Audio Upload (100MB)</td>
                            <td>3-5 seconds</td>
                            <td>Streamed, not buffered</td>
                        </tr>
                        <tr>
                            <td>Whisper Inference (30s segment)</td>
                            <td>2-5 seconds</td>
                            <td>Depends on model; tiny is 2s, small is 5s</td>
                        </tr>
                        <tr>
                            <td>CSV Save (10K records)</td>
                            <td>&lt; 100ms</td>
                            <td>O(n) with thread lock</td>
                        </tr>
                        <tr>
                            <td>Page Load (empty session)</td>
                            <td>&lt; 500ms</td>
                            <td>Fast, no database queries</td>
                        </tr>
                        <tr>
                            <td>1000 File Transcription</td>
                            <td>~2 hours (single GPU)</td>
                            <td>Linear with file count</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h2>Lessons Learned</h2>

            <h3>1. Simplicity > Perfection</h3>
            <p>
                I initially designed with database backends and complex state machines. Realizing 80% of needs are 
                met by CSV + JSON dramatically simplified the entire system. No migrations, no schema changes, no 
                query optimization needed.
            </p>

            <h3>2. Threading is Underrated for Single-Server Deployments</h3>
            <p>
                Task queues solve real problems at scale, but for teams up to ~50 users, threading handles background 
                jobs elegantly without operational overhead.
            </p>

            <h3>3. Client-Side Session Tracking is Powerful</h3>
            <p>
                localStorage eliminates the need for a per-user backend session store. Users get persistent progress 
                tracking without server state.
            </p>

            <h3>4. Audio Streaming Matters</h3>
            <p>
                Loading 500MB files into memory causes crashes. FFmpeg's streaming approach with segment serving keeps 
                memory usage constant regardless of file size.
            </p>

            <h2>What's Next?</h2>
            <p>
                Current version uses threading with JSON persistence. Future enhancements could include:
            </p>

            <ul>
                <li><strong>Multi-User Support:</strong> Add authentication and per-user tracking</li>
                <li><strong>Celery Migration:</strong> For distributed processing across multiple workers</li>
                <li><strong>Database Backend:</strong> PostgreSQL for multi-user, audit logs</li>
                <li><strong>Speaker Diarization:</strong> Identify different speakers in audio</li>
                <li><strong>Quality Metrics:</strong> Auto-detect low-quality transcriptions requiring review</li>
                <li><strong>Custom Models:</strong> Fine-tune Whisper on domain-specific audio</li>
            </ul>

            <h2>Try It Yourself</h2>
            <p>
                The complete system is open source and production-ready. You can:
            </p>

            <ul>
                <li>Set up locally in 5 minutes (see QUICK_START.md)</li>
                <li>Use review workflow with pre-transcribed audio</li>
                <li>Use auto-transcribe with any audio folder</li>
                <li>Deploy to production with Gunicorn + Nginx</li>
                <li>Extend with custom Whisper models or features</li>
            </ul>

            <blockquote>
                "Building annotation tools forces you to think about real-world constraints: large files, 
                long-running jobs, session state, and user experience. The solutions you develop generalize to 
                many web applications."
            </blockquote>

            <div style="margin-top: 3rem; padding: 2rem; background: var(--secondary-bg); border-radius: 15px; border: 1px solid var(--border-color);">
                <h3 style="margin-top: 0;">Resources & Links</h3>
                <ul style="margin-bottom: 2rem;">
                    <li><a href="../projects/project-4.html" style="color: var(--accent-color);">Full Project Page</a></li>
                    <li><a href="https://github.com/inboxpraveen/Speech-Annotation-Tool" style="color: var(--accent-color);" target="_blank">GitHub Repository</a></li>
                    <li><a href="https://github.com/openai/whisper" style="color: var(--accent-color);" target="_blank">OpenAI Whisper</a></li>
                    <li><a href="https://flask.palletsprojects.com/" style="color: var(--accent-color);" target="_blank">Flask Documentation</a></li>
                    <li><a href="https://ffmpeg.org/" style="color: var(--accent-color);" target="_blank">FFmpeg Documentation</a></li>
                </ul>
                
                <h4>Tags:</h4>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 1rem;">
                    <span class="tech-tag">#Flask</span>
                    <span class="tech-tag">#AudioProcessing</span>
                    <span class="tech-tag">#BackgroundJobs</span>
                    <span class="tech-tag">#Python</span>
                    <span class="tech-tag">#Whisper</span>
                    <span class="tech-tag">#FFmpeg</span>
                    <span class="tech-tag">#WebDevelopment</span>
                    <span class="tech-tag">#SpeechRecognition</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer style="margin-top: 4rem;">
        <div class="container">
            <p>&copy; <span id="copyright-year"></span> Praveen Kumar. Built with passion for AI & open source community.</p>
        </div>
    </footer>

    <script>
        // Mobile menu functionality
        const mobileMenu = document.getElementById('mobileMenu');
        const navLinks = document.getElementById('navLinks');

        mobileMenu.addEventListener('click', () => {
            navLinks.classList.toggle('active');
        });

        // Copy button functionality
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('copy-button')) {
                const codeBlock = e.target.closest('.code-block');
                const code = codeBlock.querySelector('pre').textContent;
                
                navigator.clipboard.writeText(code).then(() => {
                    e.target.textContent = 'Copied!';
                    setTimeout(() => {
                        e.target.textContent = 'Copy';
                    }, 2000);
                });
            }
        });

        // Navbar background on scroll
        window.addEventListener('scroll', () => {
            const nav = document.querySelector('nav');
            if (window.scrollY > 100) {
                nav.style.background = 'rgba(10, 10, 10, 0.98)';
            } else {
                nav.style.background = 'rgba(10, 10, 10, 0.95)';
            }
        });

        // Update copyright year dynamically
        window.addEventListener('load', function() {
            const yearElement = document.getElementById('copyright-year');
            if (yearElement) {
                yearElement.textContent = new Date().getFullYear();
            }
        });
    </script>
</body>
</html>
